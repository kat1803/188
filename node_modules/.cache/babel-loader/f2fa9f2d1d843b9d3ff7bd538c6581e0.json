{"ast":null,"code":"import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\nimport NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = (route, navStateKey) => ({});\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [NavigationActions.SET_PARAMS, // Todo: make SwitchRouter not depend on StackActions..\n  StackActions.COMPLETE_TRANSITION].includes(actionType);\n}\n\nexport default ((routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const order = config.order || Object.keys(routeConfigs);\n  const getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const childRouters = {};\n  order.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  const _createPathParser = createPathParser(childRouters, routeConfigs, config.paths),\n        getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n        getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(n => \"\\\"\".concat(n, \"\\\"\")).join(', ')));\n  }\n\n  function resetChildRoute(routeName) {\n    const params = routeName === initialRouteName ? initialRouteParams : undefined;\n    const childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return { ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params\n      };\n    }\n\n    return {\n      key: routeName,\n      routeName,\n      params\n    };\n  }\n\n  function getNextState(prevState, possibleNextState) {\n    if (!prevState) {\n      return possibleNextState;\n    }\n\n    let nextState;\n\n    if (prevState.index !== possibleNextState.index && resetOnBlur) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      return { ...possibleNextState,\n        routes: nextRoutes\n      };\n    } else {\n      nextState = possibleNextState;\n    }\n\n    return nextState;\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    return {\n      routes,\n      index: initialRouteIndex,\n      isTransitioning: false\n    };\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState\n      } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(route => ({ ...route,\n            params: { ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName ? initialRouteParams : null)\n            }\n          }));\n        }\n      } // Let the current child handle it\n\n\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(prevState, { ...state,\n            routes\n          });\n        }\n      } // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n\n\n      const isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && shouldBackNavigateToInitialRoute) {\n          activeChildIndex = initialRouteIndex;\n        } else {\n          return state;\n        }\n      }\n\n      let didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState;\n\n          if (action.action) {\n            newChildState = childRouter ? childRouter.getStateForAction(action.action, childState) : null;\n          } else if (!action.action && action.params) {\n            newChildState = { ...childState,\n              params: { ...(childState.params || {}),\n                ...action.params\n              }\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            return getNextState(prevState, { ...state,\n              routes,\n              index: activeChildIndex\n            });\n          } else if (!newChildState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return getNextState(prevState, { ...state,\n            routes\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(prevState, { ...state,\n          index: activeChildIndex\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state\n        };\n      } // Let other children handle it and switch to the first child that returns a new state\n\n\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n\n        if (i === index) {\n          return false;\n        }\n\n        let childState = routes[i];\n\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n\n        if (!childState) {\n          index = i;\n          return true;\n        }\n\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n\n        return false;\n      }); // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return getNextState(prevState, { ...state,\n          index,\n          routes\n        });\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      const childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, config.navigationOptions)\n  };\n});","map":null,"metadata":{},"sourceType":"module"}