{"ast":null,"code":"/*\n * This is used to extract one children's worth of events from a stream of navigation action events\n *\n * Based on the 'action' events that get fired for this navigation state, this utility will fire\n * focus and blur events for this child\n */\nexport default function getChildEventSubscriber(addListener, key) {\n  const actionSubscribers = new Set();\n  const willFocusSubscribers = new Set();\n  const didFocusSubscribers = new Set();\n  const willBlurSubscribers = new Set();\n  const didBlurSubscribers = new Set();\n\n  const removeAll = () => {\n    [actionSubscribers, willFocusSubscribers, didFocusSubscribers, willBlurSubscribers, didBlurSubscribers].forEach(set => set.clear());\n    upstreamSubscribers.forEach(subs => subs && subs.remove());\n  };\n\n  const getChildSubscribers = evtName => {\n    switch (evtName) {\n      case 'action':\n        return actionSubscribers;\n\n      case 'willFocus':\n        return willFocusSubscribers;\n\n      case 'didFocus':\n        return didFocusSubscribers;\n\n      case 'willBlur':\n        return willBlurSubscribers;\n\n      case 'didBlur':\n        return didBlurSubscribers;\n\n      default:\n        return null;\n    }\n  };\n\n  const emit = (type, payload) => {\n    const payloadWithType = { ...payload,\n      type\n    };\n    const subscribers = getChildSubscribers(type);\n    subscribers && subscribers.forEach(subs => {\n      subs(payloadWithType);\n    });\n  }; // lastEmittedEvent keeps track of focus state for one route. First we assume\n  // we are blurred. If we are focused on initialization, the first 'action'\n  // event will cause onFocus+willFocus events because we had previously been\n  // considered blurred\n\n\n  let lastEmittedEvent = 'didBlur';\n  const upstreamEvents = ['willFocus', 'didFocus', 'willBlur', 'didBlur', 'action'];\n  const upstreamSubscribers = upstreamEvents.map(eventName => addListener(eventName, payload => {\n    const state = payload.state,\n          lastState = payload.lastState,\n          action = payload.action;\n    const lastRoutes = lastState && lastState.routes;\n    const routes = state && state.routes;\n    const lastFocusKey = lastState && lastState.routes && lastState.routes[lastState.index].key;\n    const focusKey = routes && routes[state.index].key;\n    const isChildFocused = focusKey === key;\n    const lastRoute = lastRoutes && lastRoutes.find(route => route.key === key);\n    const newRoute = routes && routes.find(route => route.key === key);\n    const childPayload = {\n      context: \"\".concat(key, \":\").concat(action.type, \"_\").concat(payload.context || 'Root'),\n      state: newRoute,\n      lastState: lastRoute,\n      action,\n      type: eventName\n    };\n    const isTransitioning = !!state && state.isTransitioning;\n    const previouslyLastEmittedEvent = lastEmittedEvent;\n\n    if (lastEmittedEvent === 'didBlur') {\n      // The child is currently blurred. Look for willFocus conditions\n      if (eventName === 'willFocus' && isChildFocused) {\n        emit(lastEmittedEvent = 'willFocus', childPayload);\n      } else if (eventName === 'action' && isChildFocused) {\n        emit(lastEmittedEvent = 'willFocus', childPayload);\n      }\n    }\n\n    if (lastEmittedEvent === 'willFocus') {\n      // We are currently mid-focus. Look for didFocus conditions.\n      // If state.isTransitioning is false, this child event happens immediately after willFocus\n      if (eventName === 'didFocus' && isChildFocused && !isTransitioning) {\n        emit(lastEmittedEvent = 'didFocus', childPayload);\n      } else if (eventName === 'action' && isChildFocused && !isTransitioning) {\n        emit(lastEmittedEvent = 'didFocus', childPayload);\n      }\n    }\n\n    if (lastEmittedEvent === 'didFocus') {\n      // The child is currently focused. Look for blurring events\n      if (!isChildFocused) {\n        // The child is no longer focused within this navigation state\n        emit(lastEmittedEvent = 'willBlur', childPayload);\n      } else if (eventName === 'willBlur') {\n        // The parent is getting a willBlur event\n        emit(lastEmittedEvent = 'willBlur', childPayload);\n      } else if (eventName === 'action' && previouslyLastEmittedEvent === 'didFocus') {\n        // While focused, pass action events to children for grandchildren focus\n        emit('action', childPayload);\n      }\n    }\n\n    if (lastEmittedEvent === 'willBlur') {\n      // The child is mid-blur. Wait for transition to end\n      if (eventName === 'action' && !isChildFocused && !isTransitioning) {\n        // The child is done blurring because transitioning is over, or isTransitioning\n        // never began and didBlur fires immediately after willBlur\n        emit(lastEmittedEvent = 'didBlur', childPayload);\n      } else if (eventName === 'didBlur') {\n        // Pass through the parent didBlur event if it happens\n        emit(lastEmittedEvent = 'didBlur', childPayload);\n      }\n    }\n\n    if (lastEmittedEvent === 'didBlur' && !newRoute) {\n      removeAll();\n    }\n  }));\n  return {\n    addListener(eventName, eventHandler) {\n      const subscribers = getChildSubscribers(eventName);\n\n      if (!subscribers) {\n        throw new Error(\"Invalid event name \\\"\".concat(eventName, \"\\\"\"));\n      }\n\n      subscribers.add(eventHandler);\n\n      const remove = () => {\n        subscribers.delete(eventHandler);\n      };\n\n      return {\n        remove\n      };\n    }\n\n  };\n}","map":null,"metadata":{},"sourceType":"module"}