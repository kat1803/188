{"ast":null,"code":"import NavigationActions from '../NavigationActions';\nimport StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\n\nconst defaultActionCreators = (route, navStateKey) => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default ((routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs); // Loop through routes and find child routers\n\n  routeNames.forEach(routeName => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n  const initialRouteParams = stackConfig.initialRouteParams;\n  const getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName]; // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {}; // The router is null for normal leaf routes\n\n      if (childRouter !== null) {\n        const childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [{\n          params: action.params,\n          ...childState,\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        }]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    const params = (route.params || action.params || initialRouteParams) && { ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {})\n    };\n    const initialRouteKey = stackConfig.initialRouteKey;\n    route = { ...route,\n      ...(params ? {\n        params\n      } : {}),\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  const _createPathParser = createPathParser(childRouters, routeConfigs, stackConfig.paths),\n        getPathAndParamsForRoute = _createPathParser.getPathAndParamsForRoute,\n        getActionForPathAndParams = _createPathParser.getActionForPathAndParams;\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const routeName = activeChildRoute.routeName;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return { ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) => StackActions.pop({\n          n,\n          ...params\n        }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) => StackActions.push({\n          routeName,\n          params,\n          action\n        }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey\n            });\n          }\n\n          invariant(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          invariant(params == null, 'Params must not be provided to .replace() when specifying an object');\n          invariant(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          invariant(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) => StackActions.reset({\n          actions,\n          index: index == null ? actions.length - 1 : index,\n          key: navStateKey\n        }),\n        dismiss: () => NavigationActions.back({\n          key: navStateKey\n        })\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(action, activeChildRoute);\n\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(state, activeChildRoute.key, route, // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n            action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction = action.routeName === childRoute.routeName && action.action ? action.action : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(childAction, childRoute);\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(state, nextRouteState ? nextRouteState.key : childRoute.key, nextRouteState ? nextRouteState : childRoute);\n              return { ...newState,\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              };\n            }\n          }\n        }\n      } // Handle explicit push navigation action. This must happen after the\n      // focused child router has had a chance to handle the action.\n\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n        invariant(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action'); // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          } // Remove the now unused routes at the tail of the routes array\n\n\n          const routes = state.routes.slice(0, lastRouteIndex + 1); // Apply params if provided, otherwise leave route identity intact\n\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = { ...route,\n              params: { ...route.params,\n                ...action.params\n              }\n            };\n          } // Return state with new index. Change isTransitioning only if index has changed\n\n\n          return { ...state,\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes\n          };\n        }\n\n        if (childRouter) {\n          const childAction = action.action || NavigationActions.init({\n            params: action.params\n          });\n          route = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        } else {\n          route = {\n            params: action.params,\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n\n        return { ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true\n        };\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        // Return the state identity to bubble the action up\n        return state;\n      } // Handle navigation to other child routers that are not yet pushed\n\n\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(NavigationActions.init()); // Then check to see if the router handles our navigate action\n\n            const navigatedChildRoute = childRouter.getStateForAction(action, initChildRoute);\n            let routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              const route = { ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              };\n              return { ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true\n              };\n            }\n          }\n        }\n      } // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n\n\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        } // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n\n\n        if (state.index > 0) {\n          return { ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          };\n        }\n\n        return state;\n      } // Handle replace action\n\n\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex; // If the key param is undefined, set the index to the last route in the stack\n\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        } // Only replace if the key matches one of our routes\n\n\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n\n          if (childRouter) {\n            const childAction = action.action || NavigationActions.init({\n              params: action.params\n            });\n            childState = childRouter.getStateForAction(childAction);\n          }\n\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: action.params,\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          };\n          return { ...state,\n            routes\n          };\n        }\n      } // Update transitioning state\n\n\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && state.isTransitioning) {\n        return { ...state,\n          isTransitioning: false\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return { ...state,\n            routes\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key != state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n\n        const newStackActions = action.actions;\n        return { ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n            let childState = {};\n\n            if (router) {\n              const childAction = newStackAction.action || NavigationActions.init({\n                params: newStackAction.params\n              });\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: newStackAction.params,\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            };\n          }),\n          index: action.index\n        };\n      }\n\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        const key = action.key,\n              n = action.n,\n              immediate = action.immediate;\n        let backRouteIndex = state.index;\n\n        if (action.type === StackActions.POP && n != null) {\n          // determine the index to go back *from*. In this case, n=1 means to go\n          // back from state.index, as if it were a normal \"BACK\" action\n          backRouteIndex = Math.max(1, state.index - n + 1);\n        } else if (key) {\n          const backRoute = state.routes.find(route => route.key === key);\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n\n        if (backRouteIndex > 0) {\n          return { ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n            isTransitioning: immediate !== true\n          };\n        }\n      } // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1; // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        } // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n\n\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n\n        let childRouter = childRouters[childRoute.routeName];\n\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route, // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n            action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.navigationOptions)\n  };\n});","map":null,"metadata":{},"sourceType":"module"}